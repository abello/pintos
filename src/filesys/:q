#include "filesys/cache.h"
#include "filesys/filesys.h"
#include "threads/malloc.h"

static off_t cache_evict(void);
static struct *cache_entry cache_miss(block_sector_t sector_idx);

/*! Initialize the buffer cache by malloc'ing the space it needs. */
static void cache_init(void) {
    cache = malloc(BLOCK_SECTOR_SIZE * CACHE_SIZE);
    hash_init(&cache_table, &cache_hash, &cache_less, NULL);
}

/*! Find the cached sector at SECTOR_IDX and write SIZE bytes at offset
    OFFSET. */
void cache_read(block_sector_t sector_idx, void *buffer, off_t size,
                off_t offset) {
    struct cache_entry ce; 
    struct cache_entry *stored_ce;

    ASSERT(offset + size <= BLOCK_SECTOR_SIZE);

    ce.sector_idx = sector_idx;
    stored_ce = hash_find(&cache_table, &ce.elem); 
    if (stored_ce == NULL) {
        stored_ce = cache_miss(sector_idx);
    }
    else {
        stored_ce->accessed = 1;
    }

    memcpy(buffer, stored_ce->data + (void *) offset, (size_t) size);
}

/*! Find the cached sector at SECTOR_IDX and write SIZE bytes starting at 
    OFFSET from BUFFER to the cached sector. */
void cache_write(block_sector_t sector_idx, void *buffer, off_t size,
                 off_t offset) {
    struct cache_entry ce;
    struct cache_entry *stored_ce;

    ASSERT(offset + size <= BLOCK_SECTOR_SIZE); 

    ce.sector_idx = sector_idx;
    stored_ce = hash_find(&cache_table, &ce.elem);
    if (stored_ce == NULL) {
        stored_ce = cache_miss(sector_idx);
    } 
    else {
        stored_ce->accessed = 1;
    }

    memcpy(stored_ce->data + (void *) offset, buffer, (size_t) size);
    stored_ce->dirty = 1;
}

static void cache_evict(void) {
    /* TODO: Implement. */
    return;
}

/* Called in cache_read and cache_write when the desired block is not cached.
   Store it in the cache, then return its corresponding cache_entry struct. */
static struct cache_entry *cache_miss(block_sector_t sector_idx) {
    struct cache_entry *ce; 
    ce = malloc(sizeof(struct cache_entry));
    if (ce == NULL) {
        PANIC("Filesystem cache failure.");
    }
    if (hash_size(&cache_table) == CACHE_SIZE) {
        cache_evict();
    }
    /* TODO: synchronization: what if another process adds to the cache table
       before we do? */ 
    ce->data = malloc(BLOCK_SECTOR_SIZE);
    if (ce->data == NULL) {
        PANIC("Filesystem cache failure.");
    }
    block_read(fs_device, sector_idx, ce->data);
    ce->accessed = 0;
    ce->dirty = 0;
    hash_insert(&cache_table, &ce->elem);
    return ce;
}

unsigned cache_hash(const struct hash_elem *element, void *aux UNUSED) {
    struct cache_entry *ce = hash_entry(element, struct cache_entry, elem);
    return hash_int(ce->sector_idx);
}

bool cache_less(const struct hash_elem *a, const struct hash_elem *b,
                void *aux UNUSED) {
    struct cache_entry *ce1 = hash_entry(a, struct cache_entry, elem);
    struct cache_entry *ce2 = hash_entry(b, struct cache_entry, elem);
    return ce1->sector_idx < ce2->sector_idx;
}
